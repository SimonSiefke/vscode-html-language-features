"use strict";
exports.__esModule = true;
var fs = require("fs");
var path = require("path");
var PACKAGE_TSCONFIG = 'tsconfig.package.json';
var PROJECT_TSCONFIG = 'tsconfig.project.json';
var TSCONFIG_COMMENT = "// GENERATED by update-package-tsconfig\n";
var packagesRoot = path.join(__dirname, '..', 'packages');
var packageDirectories = fs.readdirSync(packagesRoot).filter(function (item) { return (fs.lstatSync(path.join(packagesRoot, item)).isDirectory()); });
var packageJSONMap = new Map();
var packageDirnameMap = new Map();
packageDirectories.forEach(function (packageDirname) {
    var packageJSONPath = path.join(packagesRoot, packageDirname, 'package.json');
    var packageJSONData = JSON.parse(fs.readFileSync(packageJSONPath).toString());
    var packageName = packageJSONData.name;
    packageDirnameMap.set(packageName, packageDirname);
    packageJSONMap.set(packageName, packageJSONData);
});
var internalDependencyMap = new Map();
packageDirnameMap.forEach(function (_packageDirname, packageName) {
    var _a = packageJSONMap.get(packageName), dependencies = _a.dependencies, devDependencies = _a.devDependencies;
    var internalDependencies = (dependencies ? Object.keys(dependencies) : []).concat((devDependencies ? Object.keys(devDependencies) : [])).filter(function (dep) { return packageDirnameMap.has(dep); });
    internalDependencyMap.set(packageName, internalDependencies);
});
function resolveInternalDependencies(dependencies) {
    var childDeps = [];
    for (var _i = 0, dependencies_1 = dependencies; _i < dependencies_1.length; _i++) {
        var idep = dependencies_1[_i];
        var deps = internalDependencyMap.get(idep);
        var res = resolveInternalDependencies(deps);
        for (var _a = 0, res_1 = res; _a < res_1.length; _a++) {
            var jdep = res_1[_a];
            childDeps.push(jdep);
        }
    }
    var resolved = childDeps.concat(dependencies);
    // remove all duplicated after the first appearance
    return resolved.filter(function (item, idx) { return resolved.indexOf(item) === idx; });
}
packageDirnameMap.forEach(function (packageDirname, packageName) {
    var tsconfigPath = path.join(packagesRoot, packageDirname, PACKAGE_TSCONFIG);
    var internalDependencies = resolveInternalDependencies(internalDependencyMap.get(packageName));
    var tsconfigData = {
        "extends": '../../tsconfig.base.json',
        compilerOptions: {
            outDir: './lib',
            rootDir: './src',
            composite: true
        },
        references: internalDependencies.map(function (dep) {
            return { path: "../" + packageDirnameMap.get(dep) + "/" + PACKAGE_TSCONFIG };
        }),
        include: ['src'],
        exclude: ['tests', 'lib']
    };
    fs.writeFileSync(tsconfigPath, TSCONFIG_COMMENT + JSON.stringify(tsconfigData, null, '  '));
});
var projectLevelTsconfigPath = path.join(packagesRoot, PROJECT_TSCONFIG);
var projectLevelTsconfigData = {
    files: [],
    references: resolveInternalDependencies(Array.from(packageDirnameMap.keys())).map(function (packageName) { return ({ path: "./" + packageDirnameMap.get(packageName) + "/" + PACKAGE_TSCONFIG }); })
};
fs.writeFileSync(projectLevelTsconfigPath, TSCONFIG_COMMENT + JSON.stringify(projectLevelTsconfigData, null, '  '));
